<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-16">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python kurzus - Változók</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="../css/materialize.min.css"  media="screen,projection"/>
    <link type="text/css" rel="stylesheet" href="../css/custom.css"  media="screen,projection"/>
</head>
<header>
    <nav>
        <div class="nav-wrapper">
            <ul id="nav-mobile" class="right">
                <li><a href="../index.html">Kezdőoldal</a></li>
                <li><a href="03-valtozok.html">Előző fejezet</a></li>
                <li><a href="05-vezerlesi-szerkezetek.html">Következő fejezet</a></li>
            </ul>
        </div>
    </nav>
</header>
<body>
    <div class="container">
        <h1>
            Műveletek
        </h1>
        <div class="card">
            <div class="card-content">
                <span class="card-title"></span>
                <p>
                    Az előző fejezetben megtudtuk, hogyan hozzunk létre különböző változókat.
                    Változóinkon különböző műveleteket szoktunk végezni.
                    Már adtunk össze számértékeket és fűztünk össze stringeket.
                    A műveletek műveleti jelek változók vagy literál értékek közé írásával végezhetőek el.
                    Érdemes a változónév vagy számértékek és a műveleti jelek közé egy szóközt írni.
                    Ez bizonyos esetekben nélkülözhetetlen ahhoz, hogy a Python fordító értelmezni tudja a kódot.
                    Más esetekben pedig nekünk segít, hogy ne folyjanak egymással össze a dolgok.
                    Most nézzünk további művelettípusokat!
                </p>
            </div>
        </div>
        <div class="card">
            <div class="card-content">
                <span class="card-title">Aritmetikai műveletek</span>
                <p>
                    Számértékekkel (legyeneke ezek egész számok vagy tizedes törtek) aritmetikai műveleteket szokás végezni.
                    Az összeadás és szorzás nagyon sok programban fontos szerepet kap.
                </p>
                <h5>Összeadás +</h5>
                <p>
                    A teljesség kedvéért ismételjük át a korábban látott összeadást.
                    Két számérték közé <b>+</b> operátort írva összeadjuk a kettőt.
                </p>
                <h5>Kivonás -</h5>
                <p>
                    Számértékek között <b>-</b> operátort írva az értékek különbségét kapjuk eredményül.
                </p>
                <h5>Szorzás *</h5>
                <p>
                    Számértékek között <b>*</b> operátort írva az értékek szorzatát kapjuk eredményül.
                </p>
                <h5>Osztás /</h5>
                <p>
                    Számértékek között <b>/</b> operátort írva az értékek hányadosát kapjuk eredményül.
                </p>
                <h5>Egészértékű osztás //</h5>
                <p>
                    Számértékek között <b>//</b> operátort írva (két törtvonal) az értékek hányadosának egész részét kapjuk eredményül.
                    A tizedes vessző utáni rész kerekítés nélkül lesz levágva.
                </p>
                <h5>Osztási maradék %</h5>
                <p>
                    Számértékek között <b>%</b> operátort írva az értékek maradékos osztása során fennmaradó maradékot kapjuk eredményül.
                </p>
                <h5>Hatványozás **</h5>
                <p>
                    Számértékek között <b>**</b> operátort írva (két aszteriszk) a baloldalsó értéket a jobboldalsó érték szerinti hatványkitevőre emeljük.
                </p>
                <pre>
                    <code>
print(10 + 3)   # = 13
print(10 - 3)   # = 7
print(10 * 3)   # = 30
print(10 / 3)   # = 3.3333333333333335
print(10 // 3)  # = 3
print(10 % 3)   # = 1
print(10 ** 3)  # = 1000
                    </code>
                </pre>
                <p>
                    Ezzel a kiíratással tesztelhetjük az előbb felsorolt aritmetikai műveleteket.
                    Érdemes megfigyelni, hogy az osztás eredményeként előálló végtelen szakaszos tizedes tört
                    véges pontossággal, és a végén 5-re kerekítve jelenik meg.
                    Ez nem szabályos kerekítés, hiszen a 3-mat szabály szerint lefelé kerekítjük.
                    Nem is igazi kerekítés ez, hanem egyszerűen a számítógép véges precizitásának eredménye az 5.
                    Az értékek bináris számrendszerben vannak tárolva.
                    Ami itt ennél lényegesebb, hogy egy előre megszabott mennyiségű helyiértéken.
                    Pythonban a <b>float</b> értékek általában 64 bitesek, de előfordulhat 32 bites is.
                    Ez azt jelenti, hogy 64 bináris számjegy áll rendelkezésre arra, hogy leírjunk egy számot.
                    Floatok esetében annyival árnyaltabb a kép, hogy változik, hogy hol található a tizedesvessző.
                    A számítógép annak megfelelően választja meg a tizedesvessző helyét, hogy éppen egy nagyon nagy számot,
                    vagy egy nagyon nagy pontosságú számot akarunk tárolni.
                    Ez automatikusan működik.
                </p>
                <p>
                    Példaként végezzünk műveleteket a 3.3333333333333335 értékkel!
                </p>
                <pre>
                    <code>               
                                    #   3.3333333333333335
print(3.3333333333333335 * 0.001)   # = 0.0033333333333333335
                    </code>
                </pre>
                <p>
                    Látszik, hogy itt több helyiértéket ír ki a program.
                    Ez azért lehetséges, mivel ez egy kisebb szám, így felszabadultak a legnagyobb helyiértékek.
                    Így a számítógép "balrább" téve a tizedesvesszőt több tizedesjegyet tud megjeleníteni.
                </p>
                <pre>
                    <code>               
                                    #      3.3333333333333335
print(3.3333333333333335 * 1.000)   # = 3333.3333333333335
                    </code>
                </pre>
                <p>
                    Itt az előzővel ellentétben egy nagyobb számot kell kiíratni, ezért vesztünk a pontosságból.
                </p>
                <p>
                    Ez a jelenség természetesen integer (egész) értékeknél nem jelentkezik.
                    Ott egyáltalán nem tárolódnak tizedesjegyek.
                </p>
                <p>
                    A műveleti sorrend a következően alakul:
                    Az összeadás és kivonás azonos precedenciájú.
                    Az szorzás és osztás egymással szintén azonos precedenciájú, és az összeadás és kivonásnál magasabb precedenciájú.
                    Azonos precedenciájú műveletek közt balról jobbra történik a műveletvégzés.
                    Ezt módosíthatjuk gömbölyű zárójelek írásával.
                    A zárójelezés persze nem csak aritmetikai műveletekkel használható.
                </p>
            </div>
        </div>
        <div class="card">
            <div class="card-content">
                <span class="card-title">Összehasonlító műveletek</span>
                <p>
                    Gyakran felmerül az igény, hogy különböző értékeket összehasonlítsunk egymással.
                    Egyenlőek-e? Hogyha nem, akkor melyik a nagyobb?
                    Ilyen és hasonló kérdések megválaszolására szolgálnak az összehasonlító műveletek (Comparison Operators).
                    Ezek mindegyike boolean típusú (logikai) értéket ad vissza eredményül.
                    A visszaadott érték True, hogyha a kifejezés teljesül, és False, hogyha nem.
                </p>
                <h5>Egyenlő ==</h5>
                <p>
                    Két érték közt <b>==</b> operátort írva (két egyenlőségjel) megkapjuk, hogy a kettő egyenlő-e.
                    A legtöbb programozási nyelv azért alkalmaz két egyenlőségjelet az egyenlőség vizsgálatára,
                    hogy megkülönböztesse azt a hozzárendelés műveletétől.
                    Korábban már láttuk, hogy a szimpla = a baloldali változóhoz rendelte a jobboldali értéket.
                    Ezt fontos tudatosítani, mert hogyha egy összehasonlításnak szánt egyenlőségjelet csak egyszeresen írunk,
                    akkor az hozzárendelést fog jelenteni. Erre nagyon figyeljünk!
                </p>
                <h5>Nem egyenlő !=</h5>
                <p>
                    Két érték közt <b>!=</b> operátort írva (felkiáltójel és egyenlőségjel) akkor kapunk igaz értéket, ha a kettő nem egyenlő.
                    Ez a == ellentettje.
                </p>
                <h5>Nagyobb &gt</h5>
                <p>
                    Két érték közt <b>&gt</b> operátort írva akkor kapunk igaz értéket, ha a baloldalsó érték nagyobb a jobboldalsónál.
                    Hogyha a baloldalsó kisebb vagy egyenlő a jobbnál, akkor hamis visszatérési értéket kapunk.
                </p>
                <h5>Kisebb &lt</h5>
                <p>
                    Két érték közt <b>&lt</b> operátort írva akkor kapunk igaz értéket, ha a baloldalsó érték kisebb a jobboldalsónál.
                    Hogyha a baloldalsó nagyobb vagy egyenlő a jobbnál, akkor hamis visszatérési értéket kapunk.
                </p>
                <h5>Nagyobb vagy egyenlő &gt=</h5>
                <p>
                    Két érték közt <b>&gt=</b> operátort írva akkor kapunk igaz értéket, ha a baloldalsó érték nagyobb vagy egyenlő a jobboldalsónál.
                    Hogyha a baloldalsó kisebb a jobbnál, akkor hamis visszatérési értéket kapunk.
                </p>
                <h5>Kisebb vagy egyenlő &lt=</h5>
                <p>
                    Két érték közt <b>&lt=</b> operátort írva akkor kapunk igaz értéket, ha a baloldalsó érték kisebb vagy egyenlő a jobboldalsónál.
                    Hogyha a baloldalsó nagyobb a jobbnál, akkor hamis visszatérési értéket kapunk.
                </p>
                <pre>
                    <code>
print(5 == 4)   # = False
print(5 != 4)   # = True
print(5 > 4)    # = True
print(5 < 4)    # = False
print(5 >= 4)   # = True
print(5 <= 4)   # = False

print(4 >= 4)   # = True
print(4 <= 4)   # = True                  
                    </code>
                </pre>
                <p>
                    Egyelőre integerek voltak az összehasonlítás tárgyai.
                    Most vizsgáljuk meg röviden a float értékek összehasonlítását!
                    Az össze eddig felsorolt komparáló művelet működik float értékekkel is.
                    A ==, !=, &gt= és &lt= operátorok használata viszont nem javasolt. Miért?
                    Korábban már esett szó a számok véges precizitásáról.
                    Tegyük fel, hogy bizonyos értékeket bonyolultabb műveletek eredményéül kapunk!
                    Ebben az esetben a számítások pontatlansága miatt lehetséges, hogy az elvárttól picit eltérő értéket kapunk.
                    Ekkor a teljes egyezés vizsgálata félrevezető lehet.
                    Hasonlóan járhatunk, hogyha azt vizsgáljuk, hogy két érték eltérő-e.
                    Ezek tudatában a &gt= és &lt= operátorok is szimplán fölöslegesek.
                    A gyakorlatban floatok egyenlőségének vizsgálatakor valamilyen hibaküszöböt vezetnek be.
                    Kíváncsiak vagyunk, hogy az x változó értéke egyezik-e 10.0-zel. 
                    A vizsgálat valahogyan így nézhet ki:
                </p>
                <pre>
                    <code>
(x > 9.9999 and x < 10.0001)
                    </code>
                </pre>
                <p>
                    Az <b>and</b> operátorról pillanatokon belül lesz szó.
                </p>
                <p>
                    Nem csak számértékek közt végezhetünk összehasonlítást.
                    Hogyha például az érdekel, hogy két embernek ugyanaz-e a neve,
                    akkor ezt könnyedén kideríthetjük az egyenlőség operátor használatával.
                    Hasonlóan jól működik a többi összehasonlító művelet.
                    Az operátorok balról jobbra haladnak a szövegen,
                    és egyesével összehasonlítják a karakterek <a href="https://hu.wikipedia.org/wiki/Unicode" target="_blank">Unicode</a> kódját.
                    Ez részben ábécésorrendet jelent, de nem teljesen. Például a nagybetűk kisebb kóddal rendelkeznek a kisbetűknél.
                    Az <b>"Alma"</b> tehát kisebb értékű, mint az "alma". Az ékezetes karakterek nagyobb kóddal rendelkeznek a latin ábécé ékezet nélküli összes karakterénél.
                    Tehát a <b>"bálna"</b> kisebb az <b>"ámbráscet"</b>-nél.
                </p>
                <pre>
                    <code>
name1 = "Tomi"
name2 = "Lajos"
name3 = "Lajos"
print(name1 == name2)           # = False
print(name2 == name3)           # = True
print("Alma" < "alma")          # = True
print("bálna" < "ámbráscet")    # = True
                    </code>
                </pre>
                <p>
                    Nem érdemes tehát ezzel a módszerel betűrendbe rakni szavakat.
                </p>
            </div>
        </div>
        <div class="card">
            <div class="card-content">
                <span class="card-title">Logikai műveletek</span>
                <p>
                    Most nézzük a logikai műveleteket! Ebből nem nem lesz sok, viszont annál fontosabbak.
                    Már volt szó boolean értékekről, illetve összehasonlító műveletekről,
                    amelyek logikai értéket adnak eredményül.
                    Ezeket hasznos lenne összekapcsolni, hogy összetettebb logikai kifejezéseket kapjunk.
                    Már találkoztunk egy ilyennel, amikor float értékek egyezését vizsgáltuk hibaküszöbbel.
                </p>
                <h5>És and</h5>
                <p>
                    Két logikai érték közt az <b>and</b> operátort írva akkor kapunk igaz értéket, ha a bal és jobb érték is igaz.
                    Hogyha legalább az egyik érték hamis, akkor az eredő kifejezés értéke is hamis lesz.
                </p>
                <h5>Vagy or</h5>
                <p>
                    Két logikai érték közt az <b>or</b> operátort írva akkor kapunk igaz értéket, ha a bal vagy jobb érték közül
                    legalább az egyik igaz.
                    Hogyha mindkét érték hamis, akkor a kifejezés értéke is hamis.
                </p>
                <h5>Negált not</h5>
                <p>
                    Egy logikai kifejezés előtt a <b>not</b> operátort írva az eredeti kifejezés negáltját kapjuk.
                    Az eredő kifejezés akkor lesz igaz értékű, ha az eredeti kifejezés hamis.
                    Az eredő kifejezés akkor lesz hamis értékű, ha az eredeti kifejezés igaz.
                    Az eddig tanult műveletek közül ez az első, amelyik nem két érték közé kerül,
                    hanem csak egy operandusa van, amit az operátor után írunk.
                </p>
                <pre>
                    <code>
print(True and True)        # = True
print(True and False)       # = False
print(False and False)      # = False

print(True or True)         # = True
print(True or False)        # = True
print(False or False)       # = False

print(not True)             # = False
print(not False)            # = True
                    </code>
                </pre>
            </div>
        </div>
        <div class="card">
            <div class="card-content">
                <span class="card-title">Hozzárendelő műveletek</span>
                <p>
                    Ebben a bekezdésben már nem tanulunk igazán újat. Csak ötvözzük a korábban tanultak egy részét.
                    Egyfajta kényelmi funkció bemutatása következik.
                    Már találkoztunk a <b>=</b>, mint hozzárendelés művelettel.
                    Sokszor van szükszég arra, hogy egy változó értékén műveletet végezzünk,
                    majd a változóban az új megváltozott értéket tovább tároljuk.
                    Ez például összeadás esetén az eddig tanultakkal valahogy így néz ki:
                </p>
                <pre>
                    <code>
en_kis_valtozom = en_kis_valtozom + 10                        
                    </code>
                </pre>
                <p>
                    Valamennyire talán érződik, hogy fölösleges kétszer kiírni a változó nevét.
                    (Hogyha mégsem érződik, akkor a következő műveletek elsajátítása után már biztosan nem lesz többé kedvünk kétszer leírni ugyanazt.)
                </p>
                <p>
                    A <b>x += y</b> művelet az <b>x = x + y</b> művelet leírását egyszerűsíti.
                    Ehhez hasonlóan létezik <b>-=</b>, <b>*=</b>, <b>/=</b>, <b>//=</b>, <b>%=</b> és <b>**=</b> operátor.
                </p>
            </div>
        </div>
        <div class="card">
            <div class="card-content">
                <span class="card-title">Összefoglaló</span>
                <p>
                    Ebben a fejezetben tanultunk egy csomó nélkülözhetetlen dolgot.
                    Többé már nem fölöslegesek a változóink! Lehet velük játszadozni.
                    A következőkben fogjuk is gyakorolni a műveletvégzést.
                    Összefoglalva tehát az eddigieket:
                </p>
                <p>
                    Tudunk változókat létrehozni, amelyek felvehetnek szám, karakterlánc és logikai értékeket.
                    (Megemlítettük, hogy tudunk listát készíteni a változókból, bár ezt eddig nem igazán használtuk ki.)
                    Számértékű változóinkon aritmetikai műveleteket végeztünk.
                    Összehasonlítottunk számokat és nem csak számokat.
                    Megemlítettük, hogy figyelni kell a float értékek összehasonlítására, mivel a számítás véges precizitású bináris számokkal történik.
                    Logikai értékű elemi kifejezéseinket <b>és</b> és <b>vagy</b> kapcsolatba hoztuk.
                    Még egy igen hasznos egyszerűsítő megoldást is tanultunk a változókon végzendő aritmetikai módosításokra.
                </p>
            </div>
        </div>

        <!--Gomb a gyakorló oldalra-->
        <div class="center-align">
            <div class="row">
                <a href="../exercises/01-muveletek.html" class="waves-effect waves-light btn-large">Műveletek gyakorlása</a>
            </div>
        </div>
        <!--Gomb a következő oldalra-->
        <div class="center-align">
            <div class="row">
                <a href="05-vezerlesi-szerkezetek.html" class="waves-effect waves-light btn-large">Következő fejezet</a>
            </div>
        </div>
    </div>

    <script type="text/javascript" src="../js/materialize.min.js"></script>
    <!-- Syntax highlighter: -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
<footer class="page-footer">
    <div class="container">
        <div class="row">
            <div class="col 16 s12">
                <h5 class="white-text">Linkek</h5>
                <ul>
                    <li><a class="grey-text text-lighten-3" href="https://www.python.org/" target="_blank">Python nyelv</a></li>
                    <li><a class="grey-text text-lighten-3" href="https://www.jetbrains.com/pycharm/" target="_blank">PyCharm IDE</a></li>
                </ul>
            </div>
        </div>
    </div>
    <div class="footer-copyright">
        <div class="container">
        © 2022 Simon Zoltán
        </div>
    </div>
</footer>
</html>